I"M6<p>We’ve been working on breaking up a large project into several smaller services linked through RESTful HTTP APIs. One such service transforms several source files and a few string parameters into binary output. This service accepts input as <a href="https://www.ietf.org/rfc/rfc2388.txt">RFC2388</a> multipart form data. As part of the project, calls from a <a href="http://www.grails.org">Grails</a>-based frontend have to be submitted to this service, with the results being returned to the user’s browser.</p>

<p>The go-to library for making HTTP requests in Groovy is <a href="http://groovy.codehaus.org/HTTP+Builder">HTTPBuilder</a>, a wrapper around Apache Commons <a href="https://hc.apache.org/httpcomponents-client-ga/">HttpClient</a>. It provides an API for building up HTTP requests without working directly with HttpClient, making for cleaner code that doesn’t look like someone pasted a bunch of Java into your Groovy service. Unfortunately, available examples seem to stop at trivial cases, bring in a <em>lot</em> of HttpClient usage, or rely on deprecated methods.</p>

<p>After reading through examples, HttpClient API documentation, and several other blog posts (<a href="http://dmitrijs.artjomenko.com/2013/06/multipart-file-upload-in-groovy.html">this one</a> being the most helpful), we now have a service that takes a few String parameters, a Map containing representations of the file components as key:value pairs, and returns a byte array after making a call to our RESTful backend service. Explanation below, code now:</p>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="kn">import</span> <span class="nn">groovyx.net.http.HTTPBuilder</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">groovyx</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">http</span><span class="o">.</span><span class="na">Method</span><span class="o">.</span><span class="na">POST</span>

<span class="kn">import</span> <span class="nn">org.apache.commons.io.IOUtils</span>
<span class="kn">import</span> <span class="nn">org.apache.http.entity.mime.MultipartEntityBuilder</span>
<span class="kn">import</span> <span class="nn">org.apache.http.entity.mime.content.ByteArrayBody</span>
<span class="kn">import</span> <span class="nn">org.apache.http.entity.mime.content.StringBody</span>

<span class="cm">/**
 * Call out to the backend build service and get byte output.
 * 
 * This service calls our backend RESTful service with a multipart HTTP POST. It receives
 * a byte stream from the service, converting it into a byte array and returning. 
 */</span>
<span class="kd">class</span> <span class="nc">MultipartPostService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">id</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">version</span>
    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">components</span>
    <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span>

    <span class="cm">/**
     * Initialize a MultipartPostService for the ID, version and file components.
     *
     * @param id String representation of the build ID
     * @param version String representation of the build version
     * @param components Map&lt;String, byte[]&gt; of the component files, filenames as keys
     */</span>
    <span class="kd">public</span> <span class="nf">MultipartPostService</span> <span class="o">(</span><span class="n">String</span> <span class="n">id</span><span class="o">,</span> <span class="n">String</span> <span class="n">version</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]&gt;</span> <span class="n">components</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span>
        <span class="k">this</span><span class="o">.</span><span class="na">version</span> <span class="o">=</span> <span class="n">version</span>
        <span class="k">this</span><span class="o">.</span><span class="na">components</span> <span class="o">=</span> <span class="n">components</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Retrieve a binary from a RESTful backend service.
     *
     * @return byte array representation of the service's output
     */</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">execute</span> <span class="o">()</span> <span class="o">{</span>
        <span class="kt">def</span> <span class="n">http</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HTTPBuilder</span><span class="o">(</span><span class="s2">"http://localhost:8080"</span><span class="o">)</span>
      
        <span class="n">http</span><span class="o">.</span><span class="na">request</span> <span class="o">(</span><span class="n">POST</span><span class="o">)</span> <span class="o">{</span> <span class="n">multipartRequest</span> <span class="o">-&gt;</span>
            <span class="n">uri</span><span class="o">.</span><span class="na">path</span> <span class="o">=</span> <span class="s1">'/build'</span>

            <span class="n">MultipartEntityBuilder</span> <span class="n">multipartRequestEntity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MultipartEntityBuilder</span><span class="o">()</span>
            <span class="n">multipartRequestEntity</span><span class="o">.</span><span class="na">addPart</span><span class="o">(</span><span class="s1">'id'</span><span class="o">,</span> <span class="k">new</span> <span class="n">StringBody</span><span class="o">(</span><span class="n">id</span><span class="o">))</span>
            <span class="n">multipartRequestEntity</span><span class="o">.</span><span class="na">addPart</span><span class="o">(</span><span class="s1">'version'</span><span class="o">,</span> <span class="k">new</span> <span class="n">StringBody</span><span class="o">(</span><span class="n">version</span><span class="o">))</span>

            <span class="n">components</span><span class="o">.</span><span class="na">each</span> <span class="o">{</span> <span class="n">name</span><span class="o">,</span> <span class="n">contents</span> <span class="o">-&gt;</span>
                <span class="n">multipartRequestEntity</span><span class="o">.</span><span class="na">addPart</span><span class="o">(</span><span class="s1">'components'</span><span class="o">,</span> <span class="k">new</span> <span class="n">ByteArrayBody</span><span class="o">(</span><span class="n">contents</span><span class="o">,</span> <span class="n">name</span><span class="o">))</span>
            <span class="o">}</span>

            <span class="n">multipartRequest</span><span class="o">.</span><span class="na">entity</span> <span class="o">=</span> <span class="n">multipartRequestEntity</span><span class="o">.</span><span class="na">build</span><span class="o">()</span>

            <span class="n">response</span><span class="o">.</span><span class="na">success</span> <span class="o">=</span> <span class="o">{</span> <span class="n">resp</span><span class="o">,</span> <span class="n">data</span> <span class="o">-&gt;</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">IOUtils</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
            <span class="o">}</span> 

            <span class="k">return</span> <span class="n">result</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="dependencies-and-imports">Dependencies and Imports</h2>

<p>For a freshly bootstrapped Grails application, you’re going to need to bring in a few extra dependencies to make this work. Here’s the dependency list with the versions that were current at the time of writing:</p>

<ul>
  <li><code>org.codehaus.groovy.modules.http-builder:http-builder:0.7.2</code></li>
  <li><code>org.apache.httpcomponents:httpclient:4.3.5</code></li>
  <li><code>org.apache.httpcomponents:httpmime:4.3.5</code></li>
</ul>

<p>This gets your the minimum dependencies required to make the above service function. Note that newer versions of HttpClient deprecate classes like <code>MultipartEntity</code>. Once you have the required dependencies brought into your project, the following imports will resolve:</p>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="cm">/* Groovy HTTPBuilder imports */</span>
<span class="kn">import</span> <span class="nn">groovyx.net.http.HTTPBuilder</span> <span class="cm">/* bring in HTTPBuilder */</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">groovyx</span><span class="o">.</span><span class="na">net</span><span class="o">.</span><span class="na">http</span><span class="o">.</span><span class="na">Method</span><span class="o">.</span><span class="na">POST</span> <span class="cm">/* bring in HTTP methods, we use POST */</span>

<span class="cm">/* Apache Commons HttpClient imports */</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.io.IOUtils</span> <span class="cm">/* we use IOUtils to convert the response stream to an array */</span>
<span class="kn">import</span> <span class="nn">org.apache.http.entity.mime.MultipartEntityBuilder</span> <span class="cm">/* we'll use the new builder strategy */</span>
<span class="kn">import</span> <span class="nn">org.apache.http.entity.mime.content.ByteArrayBody</span> <span class="cm">/* this will encapsulate our file uploads */</span>
<span class="kn">import</span> <span class="nn">org.apache.http.entity.mime.content.StringBody</span> <span class="cm">/* this will encapsulate string params */</span></code></pre></figure>

<h2 id="representing-our-inputs">Representing Our Inputs</h2>

<p>The service we’re POSTing to takes a variable number of files and transforms them into a single binary output. Our Grails frontend is only one of a number of sources that use the REST API, but all API clients typically build up a Map representing the file components before building a multipart request. This Map uses the filenames as keys, with the file’s contents as an array of bytes as the value. For the frontend, these components can be processed as the result of a POST to the frontend, as shown below:</p>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="kt">def</span> <span class="n">processedComponents</span> <span class="o">=</span> <span class="o">[:]</span>

<span class="n">request</span><span class="o">.</span><span class="na">multiFileMap</span><span class="o">[</span><span class="s1">'components'</span><span class="o">].</span><span class="na">each</span> <span class="o">{</span> <span class="n">file</span> <span class="o">-&gt;</span>
    <span class="n">processedComponents</span><span class="o">[</span><span class="n">file</span><span class="o">.</span><span class="na">fileItem</span><span class="o">.</span><span class="na">name</span><span class="o">]</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">bytes</span>
<span class="o">}</span></code></pre></figure>

<p>Representing the file components in this way allows for a single form input accepting a variable number of files. It also makes them easy to rip through, building parts for our multipart POST:</p>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">components</span><span class="o">.</span><span class="na">each</span> <span class="o">{</span> <span class="n">name</span><span class="o">,</span> <span class="n">contents</span> <span class="o">-&gt;</span>
    <span class="n">proofRequestEntity</span><span class="o">.</span><span class="na">addPart</span><span class="o">(</span><span class="s1">'components'</span><span class="o">,</span> <span class="k">new</span> <span class="n">ByteArrayBody</span><span class="o">(</span><span class="n">contents</span><span class="o">,</span> <span class="n">name</span><span class="o">))</span>
<span class="o">}</span></code></pre></figure>

<h2 id="handling-the-results">Handling the Results</h2>

<p>Once the REST API has processed our files, the ID, and the version into a single binary file, it returns a 200 status code and the byte stream. HTTPBuilder handles this by calling a success closure. Providing a closure with an arity of two will result in the response and data stream being bound to the first and second arguments, respectively. The data argument arrives as an InputStream which must be read into a byte array:</p>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">response</span><span class="o">.</span><span class="na">success</span> <span class="o">=</span> <span class="o">{</span> <span class="n">resp</span><span class="o">,</span> <span class="n">data</span> <span class="o">-&gt;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">IOUtils</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

:ET