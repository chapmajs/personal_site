I"Õ<p><a href="https://en.wikipedia.org/wiki/Ferroelectric_RAM">Ferroelectric RAM</a> is a type of nonvolatile memory that uses tiny magnetic domains on silicon to store bits of information, similar to how <a href="https://en.wikipedia.org/wiki/Magnetic-core_memory">magnetic core memory</a> does so using magnetic toroids. It is a static, nonvolatile memory requiring no refresh, no backup battery, and devices exist that can be accessed similarly to how conventional <a href="https://en.wikipedia.org/wiki/Static_random-access_memory">static RAM</a>, with a few changes. Modern devices hide the destructive read nature of FeRAM behind integrated controllers.</p>

<p>I became aware of commercially availale FeRAM around 2010, when a friend mentioned wishing he‚Äôd chosen it over <a href="https://en.wikipedia.org/wiki/Magnetoresistive_random-access_memory">MRAM</a> for a project. Samples were ordered from Ramtron, then the largest supplier of FeRAM. I switched over to their serial-access FeRAMs in a number of data logging projects with excellent results, but had a few 8K and 32K parallel FeRAMs in SOIC surface mount packages sitting in the samples bin. It seemed the perfect fit to build a S-100 board with FeRAM, as the nonvolatile nature would make front panel operation a little more practical, much in the way development and debugging could be done on earlier computers with core memory.</p>

<p class="center"><a href="/images/s100/feram/prototype_front.jpg"><img src="/images/s100/feram/scaled/prototype_front.jpg" alt="Initial Prototype" /></a> <a href="/images/s100/feram/prototype_back.jpg"><img src="/images/s100/feram/scaled/prototype_back.jpg" alt="Prototype Wiring" /></a></p>

<p>Six years later, and I‚Äôve just now finished implementing a prototype FeRAM board! There were a few challenges to oversome:</p>

<ul>
  <li>Address latching on Ramtron devices</li>
  <li>Write inhibit during powerup/powerdown</li>
  <li>Protecting memory from writes during operation</li>
</ul>

<p>For technical points, the <a href="http://www.cypress.com/file/136521/download">FM18W08 datasheet</a> is of course the best reference.</p>

<h2 id="address-latching">Address Latching</h2>

<p>Address latching wasn‚Äôt much of an issue, but did keep the FM18W08 FeRAM from being a drop-in replacement for the 62256 SRAM that my prototype started life with. The FM18W08 latches its address lines on the falling edge of /CE, meaning that it‚Äôs /CE which sets the address as valid, not /OE or /WE. To work with the FM18W08, we need to gate /CE with MWRITE or SMEMR from the S-100 bus, since MWRITE and SMEMR go high only when the address bus are valid. This can be expressed as:</p>

<p class="center"><code>(MWRITE ‚à® SMEMR) ‚àß BOARDSEL ‚áí CE</code></p>

<p>In this expression, BOARDSEL is a condition generated by address decoding elsewhere on the board. CE, the conditioned Chip Enable, comes out positive, so we‚Äôd need to invert it to get /CE. Easy to do with 7400 series TTL logic.</p>

<p>My prototype is a simple 32K setup, so BOARSEL is generated as follows:</p>

<p class="center"><code>¬¨PHANTOM ‚àß ¬¨A15 ‚áí BOARDSEL</code></p>

<p>This also means the board will respect the /PHANTOM line, which allows base memory to be overlaid with something else ‚Äì boot ROM code, in the case of my IMSAI.</p>

<h2 id="write-inhibit">Write Inhibit</h2>

<p>Write inhibit is necessary on any nonvolatile memory system ‚Äì even floppy disks. A lack of write inhibit during power transitions and restarts can corrupt data as the microprocessor enters undefined states with the ramp-up or collapse of various power supplies. This is why you‚Äôre never supposed to power-on or power-off a vintage computer with a floppy disk in the drive!</p>

<p>Battery-backed SRAM often overcomes this problem with an internal cutover circuit. Other systems, including most modern PCs, receive a ‚ÄúPower OK‚Äù signal from the power supply and/or a ‚ÄúPower Fail‚Äù signal to indicate impending power loss. The S-100 bus presents a special case in this area, as you have a large unregulated supply coming up, plus a number of small, independent regulated supplies coming up at their own rates. The IEEE-696 standard provided /PWRFAIL on pin 13, but early systems like the IMSAI and Altair don‚Äôt supply a /PWRFAIL signal.</p>

<p>The FM18W08 does include its own write inhibit circuitry, but it is a wide-voltage device, operating from 2.7V to 5.5V. The lower end of this spec leave plenty of room for problems with a 5V nominal system ‚Äì below 4.5V, operation is undefined and may include spurious writes.</p>

<p class="center"><a href="/images/s100/feram/powerup_protect.jpg"><img src="/images/s100/feram/scaled/powerup_protect.jpg" alt="Powerup Cutout Circuit" /></a></p>

<p>My solution was to monitor the local regulator on the FeRAM board, then wait a predetermined amount of time before releasing the /PRESET signal and allowing writes to the FeRAM. This was accomplished using a Maxim <a href="https://datasheets.maximintegrated.com/en/ds/ICL7665.pdf">ICL7665</a> voltage monitor and a 555 timer for the delay. /PRESET and write control was accomplished using a DPDT relay, with MWRITE routed through the normally open contacts, and pulled to ground through a 4.7K resistor. I included a LED to indicate when write inhibit was released.</p>

<p>In practice, this seems to work fine, though on further reflection it seems monitoring the 8V rail on the bus would be the better approach. Especially on powerdown, a lightly loaded board will drop out of regulation slower than a heavily loaded board. Future revisions will take this route, perhaps also monitoring the +/- 16V rails as well. Presumably the 16V rails come up quicker than the 8V rail, but all three are required for old CPUs like the Intel 8080.</p>

<h2 id="protecting-memory-during-operation">Protecting Memory During Operation</h2>

<p>The original Altair 8800 bus definition included PROT and UNPROT lines for controlling the write inhibit for blocks of memory. This let you toggle in a program and write-protect the code sections before running it ‚Äì a runaway program often trashes its own code, which means toggling everything in again. I wanted to implement this functionality in a flexible way, allowing operation with the original Altair layout as well as with systems that didn‚Äôt support PROT and UNPROT (the IMSAI doesn‚Äôt, without modification that puts the power switch on the rear panel). Additionally, write protect status should survive power loss, since the memory does.</p>

<p>While one could use battery backed low-power CMOS flip flops, a default-to-protected strategy, or a manual switch, I decided on <a href="https://en.wikipedia.org/wiki/Relay#Latching_relay">latching relays</a>. Latching relays are available in several varieties including units with a permanent magnet that holds the contacts in their electrically set positions with electrical power removed. Perfect! The latching relays could be set through PROT and UNPROT front panel controls, if present, or switched over to use an output port for other machines.</p>

<p>This feature is not yet implemented, but will be included in the current prototype. Wait for Part 2!</p>

<p class="center">
    <script language="javascript" src="https://services.glitchworks.net/counters/feram_part1"></script> BASIC reloads averted
</p>

:ET